{"ast":null,"code":"var _slicedToArray = require(\"/Users/macbookpro/Desktop/Elisa/LIHO/liho/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\nvar _asyncToGenerator = require(\"/Users/macbookpro/Desktop/Elisa/LIHO/liho/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n!function (global, factory) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? factory(exports) : \"function\" == typeof define && define.amd ? define([\"exports\"], factory) : factory((global = \"undefined\" != typeof globalThis ? globalThis : global || self).loadPyodide = {});\n}(this, function (exports) {\n  \"use strict\";\n\n  \"undefined\" != typeof globalThis ? globalThis : \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : \"undefined\" != typeof self && self;\n  var errorStackParser = {\n      exports: {}\n    },\n    stackframe = {\n      exports: {}\n    };\n  !function (module, exports) {\n    module.exports = function () {\n      function _isNumber(n) {\n        return !isNaN(parseFloat(n)) && isFinite(n);\n      }\n      function _capitalize(str) {\n        return str.charAt(0).toUpperCase() + str.substring(1);\n      }\n      function _getter(p) {\n        return function () {\n          return this[p];\n        };\n      }\n      var booleanProps = [\"isConstructor\", \"isEval\", \"isNative\", \"isToplevel\"],\n        numericProps = [\"columnNumber\", \"lineNumber\"],\n        stringProps = [\"fileName\", \"functionName\", \"source\"],\n        arrayProps = [\"args\"],\n        objectProps = [\"evalOrigin\"],\n        props = booleanProps.concat(numericProps, stringProps, arrayProps, objectProps);\n      function StackFrame(obj) {\n        if (obj) for (var i = 0; i < props.length; i++) void 0 !== obj[props[i]] && this[\"set\" + _capitalize(props[i])](obj[props[i]]);\n      }\n      StackFrame.prototype = {\n        getArgs: function getArgs() {\n          return this.args;\n        },\n        setArgs: function setArgs(v) {\n          if (\"[object Array]\" !== Object.prototype.toString.call(v)) throw new TypeError(\"Args must be an Array\");\n          this.args = v;\n        },\n        getEvalOrigin: function getEvalOrigin() {\n          return this.evalOrigin;\n        },\n        setEvalOrigin: function setEvalOrigin(v) {\n          if (v instanceof StackFrame) this.evalOrigin = v;else {\n            if (!(v instanceof Object)) throw new TypeError(\"Eval Origin must be an Object or StackFrame\");\n            this.evalOrigin = new StackFrame(v);\n          }\n        },\n        toString: function toString() {\n          var fileName = this.getFileName() || \"\",\n            lineNumber = this.getLineNumber() || \"\",\n            columnNumber = this.getColumnNumber() || \"\",\n            functionName = this.getFunctionName() || \"\";\n          return this.getIsEval() ? fileName ? \"[eval] (\" + fileName + \":\" + lineNumber + \":\" + columnNumber + \")\" : \"[eval]:\" + lineNumber + \":\" + columnNumber : functionName ? functionName + \" (\" + fileName + \":\" + lineNumber + \":\" + columnNumber + \")\" : fileName + \":\" + lineNumber + \":\" + columnNumber;\n        }\n      }, StackFrame.fromString = function (str) {\n        var argsStartIndex = str.indexOf(\"(\"),\n          argsEndIndex = str.lastIndexOf(\")\"),\n          functionName = str.substring(0, argsStartIndex),\n          args = str.substring(argsStartIndex + 1, argsEndIndex).split(\",\"),\n          locationString = str.substring(argsEndIndex + 1);\n        if (0 === locationString.indexOf(\"@\")) var parts = /@(.+?)(?::(\\d+))?(?::(\\d+))?$/.exec(locationString, \"\"),\n          fileName = parts[1],\n          lineNumber = parts[2],\n          columnNumber = parts[3];\n        return new StackFrame({\n          functionName: functionName,\n          args: args || void 0,\n          fileName: fileName,\n          lineNumber: lineNumber || void 0,\n          columnNumber: columnNumber || void 0\n        });\n      };\n      for (var i = 0; i < booleanProps.length; i++) StackFrame.prototype[\"get\" + _capitalize(booleanProps[i])] = _getter(booleanProps[i]), StackFrame.prototype[\"set\" + _capitalize(booleanProps[i])] = function (p) {\n        return function (v) {\n          this[p] = Boolean(v);\n        };\n      }(booleanProps[i]);\n      for (var j = 0; j < numericProps.length; j++) StackFrame.prototype[\"get\" + _capitalize(numericProps[j])] = _getter(numericProps[j]), StackFrame.prototype[\"set\" + _capitalize(numericProps[j])] = function (p) {\n        return function (v) {\n          if (!_isNumber(v)) throw new TypeError(p + \" must be a Number\");\n          this[p] = Number(v);\n        };\n      }(numericProps[j]);\n      for (var k = 0; k < stringProps.length; k++) StackFrame.prototype[\"get\" + _capitalize(stringProps[k])] = _getter(stringProps[k]), StackFrame.prototype[\"set\" + _capitalize(stringProps[k])] = function (p) {\n        return function (v) {\n          this[p] = String(v);\n        };\n      }(stringProps[k]);\n      return StackFrame;\n    }();\n  }(stackframe), function (module, exports) {\n    var StackFrame, FIREFOX_SAFARI_STACK_REGEXP, CHROME_IE_STACK_REGEXP, SAFARI_NATIVE_CODE_REGEXP;\n    module.exports = (StackFrame = stackframe.exports, FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\\S+:\\d+/, CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+:\\d+|\\(native\\))/m, SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\\[native code])?$/, {\n      parse: function parse(error) {\n        if (void 0 !== error.stacktrace || void 0 !== error[\"opera#sourceloc\"]) return this.parseOpera(error);\n        if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) return this.parseV8OrIE(error);\n        if (error.stack) return this.parseFFOrSafari(error);\n        throw new Error(\"Cannot parse given Error object\");\n      },\n      extractLocation: function extractLocation(urlLike) {\n        if (-1 === urlLike.indexOf(\":\")) return [urlLike];\n        var parts = /(.+?)(?::(\\d+))?(?::(\\d+))?$/.exec(urlLike.replace(/[()]/g, \"\"));\n        return [parts[1], parts[2] || void 0, parts[3] || void 0];\n      },\n      parseV8OrIE: function parseV8OrIE(error) {\n        return error.stack.split(\"\\n\").filter(function (line) {\n          return !!line.match(CHROME_IE_STACK_REGEXP);\n        }, this).map(function (line) {\n          line.indexOf(\"(eval \") > -1 && (line = line.replace(/eval code/g, \"eval\").replace(/(\\(eval at [^()]*)|(,.*$)/g, \"\"));\n          var sanitizedLine = line.replace(/^\\s+/, \"\").replace(/\\(eval code/g, \"(\").replace(/^.*?\\s+/, \"\"),\n            location = sanitizedLine.match(/ (\\(.+\\)$)/);\n          sanitizedLine = location ? sanitizedLine.replace(location[0], \"\") : sanitizedLine;\n          var locationParts = this.extractLocation(location ? location[1] : sanitizedLine),\n            functionName = location && sanitizedLine || void 0,\n            fileName = [\"eval\", \"<anonymous>\"].indexOf(locationParts[0]) > -1 ? void 0 : locationParts[0];\n          return new StackFrame({\n            functionName: functionName,\n            fileName: fileName,\n            lineNumber: locationParts[1],\n            columnNumber: locationParts[2],\n            source: line\n          });\n        }, this);\n      },\n      parseFFOrSafari: function parseFFOrSafari(error) {\n        return error.stack.split(\"\\n\").filter(function (line) {\n          return !line.match(SAFARI_NATIVE_CODE_REGEXP);\n        }, this).map(function (line) {\n          if (line.indexOf(\" > eval\") > -1 && (line = line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval:\\d+:\\d+/g, \":$1\")), -1 === line.indexOf(\"@\") && -1 === line.indexOf(\":\")) return new StackFrame({\n            functionName: line\n          });\n          var functionNameRegex = /((.*\".+\"[^@]*)?[^@]*)(?:@)/,\n            matches = line.match(functionNameRegex),\n            functionName = matches && matches[1] ? matches[1] : void 0,\n            locationParts = this.extractLocation(line.replace(functionNameRegex, \"\"));\n          return new StackFrame({\n            functionName: functionName,\n            fileName: locationParts[0],\n            lineNumber: locationParts[1],\n            columnNumber: locationParts[2],\n            source: line\n          });\n        }, this);\n      },\n      parseOpera: function parseOpera(e) {\n        return !e.stacktrace || e.message.indexOf(\"\\n\") > -1 && e.message.split(\"\\n\").length > e.stacktrace.split(\"\\n\").length ? this.parseOpera9(e) : e.stack ? this.parseOpera11(e) : this.parseOpera10(e);\n      },\n      parseOpera9: function parseOpera9(e) {\n        for (var lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i, lines = e.message.split(\"\\n\"), result = [], i = 2, len = lines.length; i < len; i += 2) {\n          var match = lineRE.exec(lines[i]);\n          match && result.push(new StackFrame({\n            fileName: match[2],\n            lineNumber: match[1],\n            source: lines[i]\n          }));\n        }\n        return result;\n      },\n      parseOpera10: function parseOpera10(e) {\n        for (var lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i, lines = e.stacktrace.split(\"\\n\"), result = [], i = 0, len = lines.length; i < len; i += 2) {\n          var match = lineRE.exec(lines[i]);\n          match && result.push(new StackFrame({\n            functionName: match[3] || void 0,\n            fileName: match[2],\n            lineNumber: match[1],\n            source: lines[i]\n          }));\n        }\n        return result;\n      },\n      parseOpera11: function parseOpera11(error) {\n        return error.stack.split(\"\\n\").filter(function (line) {\n          return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);\n        }, this).map(function (line) {\n          var argsRaw,\n            tokens = line.split(\"@\"),\n            locationParts = this.extractLocation(tokens.pop()),\n            functionCall = tokens.shift() || \"\",\n            functionName = functionCall.replace(/<anonymous function(: (\\w+))?>/, \"$2\").replace(/\\([^)]*\\)/g, \"\") || void 0;\n          functionCall.match(/\\(([^)]*)\\)/) && (argsRaw = functionCall.replace(/^[^(]+\\(([^)]*)\\)$/, \"$1\"));\n          var args = void 0 === argsRaw || \"[arguments not available]\" === argsRaw ? void 0 : argsRaw.split(\",\");\n          return new StackFrame({\n            functionName: functionName,\n            args: args,\n            fileName: locationParts[0],\n            lineNumber: locationParts[1],\n            columnNumber: locationParts[2],\n            source: line\n          });\n        }, this);\n      }\n    });\n  }(errorStackParser);\n  var ErrorStackParser = errorStackParser.exports;\n  var IN_NODE = \"undefined\" != typeof process && process.release && \"node\" === process.release.name && void 0 === process.browser;\n  var nodeUrlMod, nodeFetch, nodePath, nodeVmMod, nodeFsPromisesMod, resolvePath, pathSep, loadBinaryFile, loadScript;\n  if (resolvePath = IN_NODE ? function (path, base) {\n    return nodePath.resolve(base || \".\", path);\n  } : function (path, base) {\n    return void 0 === base && (base = location), new URL(path, base).toString();\n  }, IN_NODE || (pathSep = \"/\"), loadBinaryFile = IN_NODE ? /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(path, _file_sub_resource_hash) {\n      var response, data;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            if (!(path.startsWith(\"file://\") && (path = path.slice(\"file://\".length)), path.includes(\"://\"))) {\n              _context.next = 11;\n              break;\n            }\n            _context.next = 3;\n            return nodeFetch(path);\n          case 3:\n            response = _context.sent;\n            if (response.ok) {\n              _context.next = 6;\n              break;\n            }\n            throw new Error(\"Failed to load '\".concat(path, \"': request failed.\"));\n          case 6:\n            _context.t0 = Uint8Array;\n            _context.next = 9;\n            return response.arrayBuffer();\n          case 9:\n            _context.t1 = _context.sent;\n            return _context.abrupt(\"return\", new _context.t0(_context.t1));\n          case 11:\n            _context.next = 13;\n            return nodeFsPromisesMod.readFile(path);\n          case 13:\n            data = _context.sent;\n            return _context.abrupt(\"return\", new Uint8Array(data.buffer, data.byteOffset, data.byteLength));\n          case 15:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }));\n    return function (_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }() : /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(path, subResourceHash) {\n      var url, options, response;\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            url = new URL(path, location);\n            options = subResourceHash ? {\n              integrity: subResourceHash\n            } : {};\n            _context2.next = 4;\n            return fetch(url, options);\n          case 4:\n            response = _context2.sent;\n            if (response.ok) {\n              _context2.next = 7;\n              break;\n            }\n            throw new Error(\"Failed to load '\".concat(url, \"': request failed.\"));\n          case 7:\n            _context2.t0 = Uint8Array;\n            _context2.next = 10;\n            return response.arrayBuffer();\n          case 10:\n            _context2.t1 = _context2.sent;\n            return _context2.abrupt(\"return\", new _context2.t0(_context2.t1));\n          case 12:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, _callee2);\n    }));\n    return function (_x3, _x4) {\n      return _ref2.apply(this, arguments);\n    };\n  }(), globalThis.document) loadScript = /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(url) {\n      return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n        while (1) switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return import( /* webpackIgnore: true */url);\n          case 2:\n            return _context3.abrupt(\"return\", _context3.sent);\n          case 3:\n          case \"end\":\n            return _context3.stop();\n        }\n      }, _callee3);\n    }));\n    return function loadScript(_x5) {\n      return _ref3.apply(this, arguments);\n    };\n  }();else if (globalThis.importScripts) loadScript = /*#__PURE__*/function () {\n    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(url) {\n      return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n        while (1) switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.prev = 0;\n            globalThis.importScripts(url);\n            _context4.next = 10;\n            break;\n          case 4:\n            _context4.prev = 4;\n            _context4.t0 = _context4[\"catch\"](0);\n            if (_context4.t0 instanceof TypeError) {\n              _context4.next = 8;\n              break;\n            }\n            throw _context4.t0;\n          case 8:\n            _context4.next = 10;\n            return import( /* webpackIgnore: true */url);\n          case 10:\n          case \"end\":\n            return _context4.stop();\n        }\n      }, _callee4, null, [[0, 4]]);\n    }));\n    return function loadScript(_x6) {\n      return _ref4.apply(this, arguments);\n    };\n  }();else {\n    if (!IN_NODE) throw new Error(\"Cannot determine runtime environment\");\n    loadScript = /*#__PURE__*/function () {\n      var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(url) {\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              url.startsWith(\"file://\") && (url = url.slice(\"file://\".length));\n              if (!url.includes(\"://\")) {\n                _context5.next = 11;\n                break;\n              }\n              _context5.t0 = nodeVmMod;\n              _context5.next = 5;\n              return nodeFetch(url);\n            case 5:\n              _context5.next = 7;\n              return _context5.sent.text();\n            case 7:\n              _context5.t1 = _context5.sent;\n              _context5.t0.runInThisContext.call(_context5.t0, _context5.t1);\n              _context5.next = 13;\n              break;\n            case 11:\n              _context5.next = 13;\n              return import( /* webpackIgnore: true */nodeUrlMod.pathToFileURL(url).href);\n            case 13:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5);\n      }));\n      return function loadScript(_x7) {\n        return _ref5.apply(this, arguments);\n      };\n    }();\n  }\n  function __values(o) {\n    var s = \"function\" == typeof Symbol && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n    if (m) return m.call(o);\n    if (o && \"number\" == typeof o.length) return {\n      next: function next() {\n        return o && i >= o.length && (o = void 0), {\n          value: o && o[i++],\n          done: !o\n        };\n      }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n  }\n  function __asyncValues(o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var i,\n      m = o[Symbol.asyncIterator];\n    return m ? m.call(o) : (o = __values(o), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n      return this;\n    }, i);\n    function verb(n) {\n      i[n] = o[n] && function (v) {\n        return new Promise(function (resolve, reject) {\n          (function (resolve, reject, d, v) {\n            Promise.resolve(v).then(function (v) {\n              resolve({\n                value: v,\n                done: d\n              });\n            }, reject);\n          })(resolve, reject, (v = o[n](v)).done, v.value);\n        });\n      };\n    }\n  }\n  var getFsHandles = /*#__PURE__*/function () {\n    var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(dirHandle) {\n      var handles, result, _i, _handles, handle, relativePath;\n      return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n        while (1) switch (_context7.prev = _context7.next) {\n          case 0:\n            handles = [];\n            _context7.next = 3;\n            return function () {\n              var _collect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(curDirHandle) {\n                var e_1, _a, _c, _b, entry;\n                return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n                  while (1) switch (_context6.prev = _context6.next) {\n                    case 0:\n                      _context6.prev = 0;\n                      _b = __asyncValues(curDirHandle.values());\n                    case 2:\n                      _context6.next = 4;\n                      return _b.next();\n                    case 4:\n                      if ((_c = _context6.sent).done) {\n                        _context6.next = 13;\n                        break;\n                      }\n                      entry = _c.value;\n                      handles.push(entry);\n                      _context6.t0 = \"directory\" === entry.kind;\n                      if (!_context6.t0) {\n                        _context6.next = 11;\n                        break;\n                      }\n                      _context6.next = 11;\n                      return collect(entry);\n                    case 11:\n                      _context6.next = 2;\n                      break;\n                    case 13:\n                      _context6.next = 18;\n                      break;\n                    case 15:\n                      _context6.prev = 15;\n                      _context6.t1 = _context6[\"catch\"](0);\n                      e_1 = {\n                        error: _context6.t1\n                      };\n                    case 18:\n                      _context6.prev = 18;\n                      _context6.prev = 19;\n                      _context6.t2 = _c && !_c.done && (_a = _b.return);\n                      if (!_context6.t2) {\n                        _context6.next = 24;\n                        break;\n                      }\n                      _context6.next = 24;\n                      return _a.call(_b);\n                    case 24:\n                      _context6.prev = 24;\n                      if (!e_1) {\n                        _context6.next = 27;\n                        break;\n                      }\n                      throw e_1.error;\n                    case 27:\n                      return _context6.finish(24);\n                    case 28:\n                      return _context6.finish(18);\n                    case 29:\n                    case \"end\":\n                      return _context6.stop();\n                  }\n                }, _callee6, null, [[0, 15, 18, 29], [19,, 24, 28]]);\n              }));\n              function collect(_x9) {\n                return _collect.apply(this, arguments);\n              }\n              return collect;\n            }()(dirHandle);\n          case 3:\n            result = new Map();\n            result.set(\".\", dirHandle);\n            _i = 0, _handles = handles;\n          case 6:\n            if (!(_i < _handles.length)) {\n              _context7.next = 15;\n              break;\n            }\n            handle = _handles[_i];\n            _context7.next = 10;\n            return dirHandle.resolve(handle);\n          case 10:\n            relativePath = _context7.sent.join(\"/\");\n            result.set(relativePath, handle);\n          case 12:\n            _i++;\n            _context7.next = 6;\n            break;\n          case 15:\n            return _context7.abrupt(\"return\", result);\n          case 16:\n          case \"end\":\n            return _context7.stop();\n        }\n      }, _callee7);\n    }));\n    return function getFsHandles(_x8) {\n      return _ref6.apply(this, arguments);\n    };\n  }();\n  function finalizeBootstrap(API, config) {\n    API.runPythonInternal_dict = API._pyodide._base.eval_code(\"{}\"), API.importlib = API.runPythonInternal(\"import importlib; importlib\");\n    var import_module = API.importlib.import_module;\n    API.sys = import_module(\"sys\"), API.sys.path.insert(0, config.homedir), API.os = import_module(\"os\");\n    var globals = API.runPythonInternal(\"import __main__; __main__.__dict__\"),\n      builtins = API.runPythonInternal(\"import builtins; builtins.__dict__\");\n    var builtins_dict;\n    API.globals = (builtins_dict = builtins, new Proxy(globals, {\n      get: function get(target, symbol) {\n        return \"get\" === symbol ? function (key) {\n          var result = target.get(key);\n          return void 0 === result && (result = builtins_dict.get(key)), result;\n        } : \"has\" === symbol ? function (key) {\n          return target.has(key) || builtins_dict.has(key);\n        } : Reflect.get(target, symbol);\n      }\n    }));\n    var importhook = API._pyodide._importhook;\n    importhook.register_js_finder(), importhook.register_js_module(\"js\", config.jsglobals);\n    var pyodide = API.makePublicAPI();\n    return importhook.register_js_module(\"pyodide_js\", pyodide), API.pyodide_py = import_module(\"pyodide\"), API.pyodide_code = import_module(\"pyodide.code\"), API.pyodide_ffi = import_module(\"pyodide.ffi\"), API.package_loader = import_module(\"pyodide._package_loader\"), API.sitepackages = API.package_loader.SITE_PACKAGES.__str__(), API.dsodir = API.package_loader.DSO_DIR.__str__(), API.defaultLdLibraryPath = [API.dsodir, API.sitepackages], API.os.environ.__setitem__(\"LD_LIBRARY_PATH\", API.defaultLdLibraryPath.join(\":\")), pyodide.pyodide_py = API.pyodide_py, pyodide.globals = API.globals, pyodide;\n  }\n  function loadPyodide() {\n    return _loadPyodide.apply(this, arguments);\n  }\n  function _loadPyodide() {\n    _loadPyodide = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {\n      var options,\n        indexURL,\n        default_config,\n        config,\n        pyodide_py_tar_promise,\n        Module,\n        API,\n        moduleLoaded,\n        scriptSrc,\n        pyodide_py_tar,\n        pyodide,\n        _args15 = arguments;\n      return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n        while (1) switch (_context15.prev = _context15.next) {\n          case 0:\n            options = _args15.length > 0 && _args15[0] !== undefined ? _args15[0] : {};\n            _context15.next = 3;\n            return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n              var node_modules;\n              return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n                while (1) switch (_context8.prev = _context8.next) {\n                  case 0:\n                    if (IN_NODE) {\n                      _context8.next = 2;\n                      break;\n                    }\n                    return _context8.abrupt(\"return\");\n                  case 2:\n                    _context8.next = 4;\n                    return import(\"url\");\n                  case 4:\n                    nodeUrlMod = _context8.sent.default;\n                    _context8.next = 7;\n                    return import(\"fs/promises\");\n                  case 7:\n                    nodeFsPromisesMod = _context8.sent;\n                    if (!globalThis.fetch) {\n                      _context8.next = 12;\n                      break;\n                    }\n                    _context8.t0 = fetch;\n                    _context8.next = 15;\n                    break;\n                  case 12:\n                    _context8.next = 14;\n                    return import(\"node-fetch\");\n                  case 14:\n                    _context8.t0 = _context8.sent.default;\n                  case 15:\n                    nodeFetch = _context8.t0;\n                    _context8.next = 18;\n                    return import(\"vm\");\n                  case 18:\n                    nodeVmMod = _context8.sent.default;\n                    _context8.next = 21;\n                    return import(\"path\");\n                  case 21:\n                    nodePath = _context8.sent;\n                    pathSep = nodePath.sep;\n                    if (!(\"undefined\" != typeof require)) {\n                      _context8.next = 25;\n                      break;\n                    }\n                    return _context8.abrupt(\"return\");\n                  case 25:\n                    _context8.next = 27;\n                    return import(\"fs\");\n                  case 27:\n                    _context8.t1 = _context8.sent;\n                    _context8.next = 30;\n                    return import(\"crypto\");\n                  case 30:\n                    _context8.t2 = _context8.sent;\n                    _context8.next = 33;\n                    return import(\"ws\");\n                  case 33:\n                    _context8.t3 = _context8.sent;\n                    _context8.next = 36;\n                    return import(\"child_process\");\n                  case 36:\n                    _context8.t4 = _context8.sent;\n                    node_modules = {\n                      fs: _context8.t1,\n                      crypto: _context8.t2,\n                      ws: _context8.t3,\n                      child_process: _context8.t4\n                    };\n                    globalThis.require = function (mod) {\n                      return node_modules[mod];\n                    };\n                  case 39:\n                  case \"end\":\n                    return _context8.stop();\n                }\n              }, _callee8);\n            }))();\n          case 3:\n            indexURL = options.indexURL || function () {\n              if (\"string\" == typeof __dirname) return __dirname;\n              var err;\n              try {\n                throw new Error();\n              } catch (e) {\n                err = e;\n              }\n              var fileName = ErrorStackParser.parse(err)[0].fileName;\n              var indexOfLastSlash = fileName.lastIndexOf(pathSep);\n              if (-1 === indexOfLastSlash) throw new Error(\"Could not extract indexURL path from pyodide module location\");\n              return fileName.slice(0, indexOfLastSlash);\n            }();\n            indexURL = resolvePath(indexURL), indexURL.endsWith(\"/\") || (indexURL += \"/\"), options.indexURL = indexURL;\n            default_config = {\n              fullStdLib: !1,\n              jsglobals: globalThis,\n              stdin: globalThis.prompt ? globalThis.prompt : void 0,\n              homedir: \"/home/pyodide\",\n              lockFileURL: indexURL + \"repodata.json\",\n              args: [],\n              _node_mounts: []\n            }, config = Object.assign(default_config, options), pyodide_py_tar_promise = loadBinaryFile(config.indexURL + \"pyodide_py.tar\"), Module = function () {\n              var Module = {\n                noImageDecoding: !0,\n                noAudioDecoding: !0,\n                noWasmDecoding: !1,\n                preRun: [],\n                quit: function quit(status, toThrow) {\n                  throw Module.exited = {\n                    status: status,\n                    toThrow: toThrow\n                  }, toThrow;\n                }\n              };\n              return Module;\n            }();\n            Module.print = config.stdout, Module.printErr = config.stderr, Module.preRun.push(function () {\n              var _iterator = _createForOfIteratorHelper(config._node_mounts),\n                _step;\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  var mount = _step.value;\n                  Module.FS.mkdirTree(mount), Module.FS.mount(Module.NODEFS, {\n                    root: mount\n                  }, mount);\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n            }), Module.arguments = config.args;\n            API = {\n              config: config\n            };\n            Module.API = API, function (Module, path) {\n              Module.preRun.push(function () {\n                try {\n                  Module.FS.mkdirTree(path);\n                } catch (e) {\n                  console.error(\"Error occurred while making a home directory '\".concat(path, \"':\")), console.error(e), console.error(\"Using '/' for a home directory instead\"), path = \"/\";\n                }\n                Module.ENV.HOME = path, Module.FS.chdir(path);\n              });\n            }(Module, config.homedir);\n            moduleLoaded = new Promise(function (r) {\n              return Module.postRun = r;\n            });\n            if (!(Module.locateFile = function (path) {\n              return config.indexURL + path;\n            }, \"function\" != typeof _createPyodideModule)) {\n              _context15.next = 14;\n              break;\n            }\n            scriptSrc = \"\".concat(config.indexURL, \"pyodide.asm.js\");\n            _context15.next = 14;\n            return loadScript(scriptSrc);\n          case 14:\n            _context15.next = 16;\n            return _createPyodideModule(Module);\n          case 16:\n            _context15.next = 18;\n            return moduleLoaded;\n          case 18:\n            if (!Module.exited) {\n              _context15.next = 20;\n              break;\n            }\n            throw Module.exited.toThrow;\n          case 20:\n            if (!(\"0.22.0\" !== API.version)) {\n              _context15.next = 22;\n              break;\n            }\n            throw new Error(\"Pyodide version does not match: '0.22.0' <==> '\".concat(API.version, \"'. If you updated the Pyodide version, make sure you also updated the 'indexURL' parameter passed to loadPyodide.\"));\n          case 22:\n            Module.locateFile = function (path) {\n              throw new Error(\"Didn't expect to load any more file_packager files!\");\n            }, function (module) {\n              var FS = module.FS,\n                MEMFS = module.FS.filesystems.MEMFS,\n                PATH = module.PATH,\n                nativeFSAsync = {\n                  DIR_MODE: 16895,\n                  FILE_MODE: 33279,\n                  mount: function mount(_mount) {\n                    if (!_mount.opts.fileSystemHandle) throw new Error(\"opts.fileSystemHandle is required\");\n                    return MEMFS.mount.apply(null, arguments);\n                  },\n                  syncfs: function () {\n                    var _syncfs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(mount, populate, callback) {\n                      var local, remote, src, dst;\n                      return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n                        while (1) switch (_context9.prev = _context9.next) {\n                          case 0:\n                            _context9.prev = 0;\n                            local = nativeFSAsync.getLocalSet(mount);\n                            _context9.next = 4;\n                            return nativeFSAsync.getRemoteSet(mount);\n                          case 4:\n                            remote = _context9.sent;\n                            src = populate ? remote : local;\n                            dst = populate ? local : remote;\n                            _context9.next = 9;\n                            return nativeFSAsync.reconcile(mount, src, dst);\n                          case 9:\n                            callback(null);\n                            _context9.next = 15;\n                            break;\n                          case 12:\n                            _context9.prev = 12;\n                            _context9.t0 = _context9[\"catch\"](0);\n                            callback(_context9.t0);\n                          case 15:\n                          case \"end\":\n                            return _context9.stop();\n                        }\n                      }, _callee9, null, [[0, 12]]);\n                    }));\n                    function syncfs(_x10, _x11, _x12) {\n                      return _syncfs.apply(this, arguments);\n                    }\n                    return syncfs;\n                  }(),\n                  getLocalSet: function getLocalSet(mount) {\n                    var entries = Object.create(null);\n                    function isRealDir(p) {\n                      return \".\" !== p && \"..\" !== p;\n                    }\n                    function toAbsolute(root) {\n                      return function (p) {\n                        return PATH.join2(root, p);\n                      };\n                    }\n                    var check = FS.readdir(mount.mountpoint).filter(isRealDir).map(toAbsolute(mount.mountpoint));\n                    for (; check.length;) {\n                      var path = check.pop(),\n                        stat = FS.stat(path);\n                      FS.isDir(stat.mode) && check.push.apply(check, FS.readdir(path).filter(isRealDir).map(toAbsolute(path))), entries[path] = {\n                        timestamp: stat.mtime,\n                        mode: stat.mode\n                      };\n                    }\n                    return {\n                      type: \"local\",\n                      entries: entries\n                    };\n                  },\n                  getRemoteSet: function () {\n                    var _getRemoteSet = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(mount) {\n                      var entries, handles, _iterator2, _step2, _step2$value, path, handle;\n                      return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n                        while (1) switch (_context10.prev = _context10.next) {\n                          case 0:\n                            entries = Object.create(null);\n                            _context10.next = 3;\n                            return getFsHandles(mount.opts.fileSystemHandle);\n                          case 3:\n                            handles = _context10.sent;\n                            _iterator2 = _createForOfIteratorHelper(handles);\n                            _context10.prev = 5;\n                            _iterator2.s();\n                          case 7:\n                            if ((_step2 = _iterator2.n()).done) {\n                              _context10.next = 23;\n                              break;\n                            }\n                            _step2$value = _slicedToArray(_step2.value, 2), path = _step2$value[0], handle = _step2$value[1];\n                            _context10.t0 = \".\" !== path;\n                            if (!_context10.t0) {\n                              _context10.next = 21;\n                              break;\n                            }\n                            if (!(\"file\" === handle.kind)) {\n                              _context10.next = 17;\n                              break;\n                            }\n                            _context10.next = 14;\n                            return handle.getFile();\n                          case 14:\n                            _context10.t1 = _context10.sent.lastModifiedDate;\n                            _context10.next = 18;\n                            break;\n                          case 17:\n                            _context10.t1 = new Date();\n                          case 18:\n                            _context10.t2 = _context10.t1;\n                            _context10.t3 = \"file\" === handle.kind ? nativeFSAsync.FILE_MODE : nativeFSAsync.DIR_MODE;\n                            entries[PATH.join2(mount.mountpoint, path)] = {\n                              timestamp: _context10.t2,\n                              mode: _context10.t3\n                            };\n                          case 21:\n                            _context10.next = 7;\n                            break;\n                          case 23:\n                            _context10.next = 28;\n                            break;\n                          case 25:\n                            _context10.prev = 25;\n                            _context10.t4 = _context10[\"catch\"](5);\n                            _iterator2.e(_context10.t4);\n                          case 28:\n                            _context10.prev = 28;\n                            _iterator2.f();\n                            return _context10.finish(28);\n                          case 31:\n                            return _context10.abrupt(\"return\", {\n                              type: \"remote\",\n                              entries: entries,\n                              handles: handles\n                            });\n                          case 32:\n                          case \"end\":\n                            return _context10.stop();\n                        }\n                      }, _callee10, null, [[5, 25, 28, 31]]);\n                    }));\n                    function getRemoteSet(_x13) {\n                      return _getRemoteSet.apply(this, arguments);\n                    }\n                    return getRemoteSet;\n                  }(),\n                  loadLocalEntry: function loadLocalEntry(path) {\n                    var node = FS.lookupPath(path).node,\n                      stat = FS.stat(path);\n                    if (FS.isDir(stat.mode)) return {\n                      timestamp: stat.mtime,\n                      mode: stat.mode\n                    };\n                    if (FS.isFile(stat.mode)) return node.contents = MEMFS.getFileDataAsTypedArray(node), {\n                      timestamp: stat.mtime,\n                      mode: stat.mode,\n                      contents: node.contents\n                    };\n                    throw new Error(\"node type not supported\");\n                  },\n                  storeLocalEntry: function storeLocalEntry(path, entry) {\n                    if (FS.isDir(entry.mode)) FS.mkdirTree(path, entry.mode);else {\n                      if (!FS.isFile(entry.mode)) throw new Error(\"node type not supported\");\n                      FS.writeFile(path, entry.contents, {\n                        canOwn: !0\n                      });\n                    }\n                    FS.chmod(path, entry.mode), FS.utime(path, entry.timestamp, entry.timestamp);\n                  },\n                  removeLocalEntry: function removeLocalEntry(path) {\n                    var stat = FS.stat(path);\n                    FS.isDir(stat.mode) ? FS.rmdir(path) : FS.isFile(stat.mode) && FS.unlink(path);\n                  },\n                  loadRemoteEntry: function () {\n                    var _loadRemoteEntry = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(handle) {\n                      var file;\n                      return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n                        while (1) switch (_context11.prev = _context11.next) {\n                          case 0:\n                            if (!(\"file\" === handle.kind)) {\n                              _context11.next = 12;\n                              break;\n                            }\n                            _context11.next = 3;\n                            return handle.getFile();\n                          case 3:\n                            file = _context11.sent;\n                            _context11.t0 = Uint8Array;\n                            _context11.next = 7;\n                            return file.arrayBuffer();\n                          case 7:\n                            _context11.t1 = _context11.sent;\n                            _context11.t2 = new _context11.t0(_context11.t1);\n                            _context11.t3 = nativeFSAsync.FILE_MODE;\n                            _context11.t4 = file.lastModifiedDate;\n                            return _context11.abrupt(\"return\", {\n                              contents: _context11.t2,\n                              mode: _context11.t3,\n                              timestamp: _context11.t4\n                            });\n                          case 12:\n                            if (!(\"directory\" === handle.kind)) {\n                              _context11.next = 14;\n                              break;\n                            }\n                            return _context11.abrupt(\"return\", {\n                              mode: nativeFSAsync.DIR_MODE,\n                              timestamp: new Date()\n                            });\n                          case 14:\n                            throw new Error(\"unknown kind: \" + handle.kind);\n                          case 15:\n                          case \"end\":\n                            return _context11.stop();\n                        }\n                      }, _callee11);\n                    }));\n                    function loadRemoteEntry(_x14) {\n                      return _loadRemoteEntry.apply(this, arguments);\n                    }\n                    return loadRemoteEntry;\n                  }(),\n                  storeRemoteEntry: function () {\n                    var _storeRemoteEntry = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(handles, path, entry) {\n                      var parentDirHandle, handle, writable;\n                      return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n                        while (1) switch (_context12.prev = _context12.next) {\n                          case 0:\n                            parentDirHandle = handles.get(PATH.dirname(path));\n                            if (!FS.isFile(entry.mode)) {\n                              _context12.next = 7;\n                              break;\n                            }\n                            _context12.next = 4;\n                            return parentDirHandle.getFileHandle(PATH.basename(path), {\n                              create: !0\n                            });\n                          case 4:\n                            _context12.t0 = _context12.sent;\n                            _context12.next = 10;\n                            break;\n                          case 7:\n                            _context12.next = 9;\n                            return parentDirHandle.getDirectoryHandle(PATH.basename(path), {\n                              create: !0\n                            });\n                          case 9:\n                            _context12.t0 = _context12.sent;\n                          case 10:\n                            handle = _context12.t0;\n                            if (!(\"file\" === handle.kind)) {\n                              _context12.next = 19;\n                              break;\n                            }\n                            _context12.next = 14;\n                            return handle.createWritable();\n                          case 14:\n                            writable = _context12.sent;\n                            _context12.next = 17;\n                            return writable.write(entry.contents);\n                          case 17:\n                            _context12.next = 19;\n                            return writable.close();\n                          case 19:\n                            handles.set(path, handle);\n                          case 20:\n                          case \"end\":\n                            return _context12.stop();\n                        }\n                      }, _callee12);\n                    }));\n                    function storeRemoteEntry(_x15, _x16, _x17) {\n                      return _storeRemoteEntry.apply(this, arguments);\n                    }\n                    return storeRemoteEntry;\n                  }(),\n                  removeRemoteEntry: function () {\n                    var _removeRemoteEntry = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(handles, path) {\n                      var parentDirHandle;\n                      return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n                        while (1) switch (_context13.prev = _context13.next) {\n                          case 0:\n                            parentDirHandle = handles.get(PATH.dirname(path));\n                            _context13.next = 3;\n                            return parentDirHandle.removeEntry(PATH.basename(path));\n                          case 3:\n                            handles.delete(path);\n                          case 4:\n                          case \"end\":\n                            return _context13.stop();\n                        }\n                      }, _callee13);\n                    }));\n                    function removeRemoteEntry(_x18, _x19) {\n                      return _removeRemoteEntry.apply(this, arguments);\n                    }\n                    return removeRemoteEntry;\n                  }(),\n                  reconcile: function () {\n                    var _reconcile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(mount, src, dst) {\n                      var total, create, remove, handles, _i2, _create, path, relPath, handle, entry, _entry, _i3, _remove, _path, _relPath;\n                      return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n                        while (1) switch (_context14.prev = _context14.next) {\n                          case 0:\n                            total = 0;\n                            create = [];\n                            Object.keys(src.entries).forEach(function (key) {\n                              var e = src.entries[key],\n                                e2 = dst.entries[key];\n                              (!e2 || FS.isFile(e.mode) && e.timestamp.getTime() > e2.timestamp.getTime()) && (create.push(key), total++);\n                            }), create.sort();\n                            remove = [];\n                            if (!(Object.keys(dst.entries).forEach(function (key) {\n                              src.entries[key] || (remove.push(key), total++);\n                            }), remove.sort().reverse(), !total)) {\n                              _context14.next = 6;\n                              break;\n                            }\n                            return _context14.abrupt(\"return\");\n                          case 6:\n                            handles = \"remote\" === src.type ? src.handles : dst.handles;\n                            _i2 = 0, _create = create;\n                          case 8:\n                            if (!(_i2 < _create.length)) {\n                              _context14.next = 25;\n                              break;\n                            }\n                            path = _create[_i2];\n                            relPath = PATH.normalize(path.replace(mount.mountpoint, \"/\")).substring(1);\n                            if (!(\"local\" === dst.type)) {\n                              _context14.next = 19;\n                              break;\n                            }\n                            handle = handles.get(relPath);\n                            _context14.next = 15;\n                            return nativeFSAsync.loadRemoteEntry(handle);\n                          case 15:\n                            entry = _context14.sent;\n                            nativeFSAsync.storeLocalEntry(path, entry);\n                            _context14.next = 22;\n                            break;\n                          case 19:\n                            _entry = nativeFSAsync.loadLocalEntry(path);\n                            _context14.next = 22;\n                            return nativeFSAsync.storeRemoteEntry(handles, relPath, _entry);\n                          case 22:\n                            _i2++;\n                            _context14.next = 8;\n                            break;\n                          case 25:\n                            _i3 = 0, _remove = remove;\n                          case 26:\n                            if (!(_i3 < _remove.length)) {\n                              _context14.next = 38;\n                              break;\n                            }\n                            _path = _remove[_i3];\n                            if (!(\"local\" === dst.type)) {\n                              _context14.next = 32;\n                              break;\n                            }\n                            nativeFSAsync.removeLocalEntry(_path);\n                            _context14.next = 35;\n                            break;\n                          case 32:\n                            _relPath = PATH.normalize(_path.replace(mount.mountpoint, \"/\")).substring(1);\n                            _context14.next = 35;\n                            return nativeFSAsync.removeRemoteEntry(handles, _relPath);\n                          case 35:\n                            _i3++;\n                            _context14.next = 26;\n                            break;\n                          case 38:\n                          case \"end\":\n                            return _context14.stop();\n                        }\n                      }, _callee14);\n                    }));\n                    function reconcile(_x20, _x21, _x22) {\n                      return _reconcile.apply(this, arguments);\n                    }\n                    return reconcile;\n                  }()\n                };\n              module.FS.filesystems.NATIVEFS_ASYNC = nativeFSAsync;\n            }(Module);\n            _context15.next = 25;\n            return pyodide_py_tar_promise;\n          case 25:\n            pyodide_py_tar = _context15.sent;\n            !function (Module, pyodide_py_tar) {\n              var stream = Module.FS.open(\"/pyodide_py.tar\", \"w\");\n              Module.FS.write(stream, pyodide_py_tar, 0, pyodide_py_tar.byteLength, void 0, !0), Module.FS.close(stream);\n              var _Module$API$rawRun = Module.API.rawRun('\\nfrom sys import version_info\\npyversion = f\"python{version_info.major}.{version_info.minor}\"\\nimport shutil\\nshutil.unpack_archive(\"/pyodide_py.tar\", f\"/lib/{pyversion}/\")\\ndel shutil\\nimport importlib\\nimportlib.invalidate_caches()\\ndel importlib\\n'),\n                _Module$API$rawRun2 = _slicedToArray(_Module$API$rawRun, 2),\n                errcode = _Module$API$rawRun2[0],\n                captured_stderr = _Module$API$rawRun2[1];\n              errcode && Module.API.fatal_loading_error(\"Failed to unpack standard library.\\n\", captured_stderr), Module.FS.unlink(\"/pyodide_py.tar\");\n            }(Module, pyodide_py_tar), API.rawRun(\"import _pyodide_core\");\n            pyodide = finalizeBootstrap(API, config);\n            pyodide.version.includes(\"dev\") || API.setCdnUrl(\"https://cdn.jsdelivr.net/pyodide/v\".concat(pyodide.version, \"/full/\"));\n            _context15.next = 31;\n            return API.packageIndexReady;\n          case 31:\n            API._pyodide._importhook.register_module_not_found_hook(API.repodata_packages);\n            if (!(\"0.22.0\" !== API.repodata_info.version)) {\n              _context15.next = 34;\n              break;\n            }\n            throw new Error(\"Lock file version doesn't match Pyodide version\");\n          case 34:\n            API.package_loader.init_loaded_packages();\n            _context15.t0 = config.fullStdLib;\n            if (!_context15.t0) {\n              _context15.next = 39;\n              break;\n            }\n            _context15.next = 39;\n            return pyodide.loadPackage(API._pyodide._importhook.UNVENDORED_STDLIBS);\n          case 39:\n            API.initializeStreams(config.stdin, config.stdout, config.stderr);\n            return _context15.abrupt(\"return\", pyodide);\n          case 41:\n          case \"end\":\n            return _context15.stop();\n        }\n      }, _callee15);\n    }));\n    return _loadPyodide.apply(this, arguments);\n  }\n  globalThis.loadPyodide = loadPyodide, exports.loadPyodide = loadPyodide, exports.version = \"0.22.0\", Object.defineProperty(exports, \"__esModule\", {\n    value: !0\n  });\n});","map":null,"metadata":{},"sourceType":"script"}