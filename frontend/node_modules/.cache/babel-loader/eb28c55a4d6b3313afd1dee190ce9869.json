{"ast":null,"code":"import _objectSpread from \"/Users/macbookpro/Desktop/Elisa/LIHO/liho/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport _possibleConstructorReturn from \"/Users/macbookpro/Desktop/Elisa/LIHO/liho/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/macbookpro/Desktop/Elisa/LIHO/liho/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/macbookpro/Desktop/Elisa/LIHO/liho/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _classCallCheck from \"/Users/macbookpro/Desktop/Elisa/LIHO/liho/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/macbookpro/Desktop/Elisa/LIHO/liho/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { ElementType, isTag as isTagRaw } from \"domelementtype\";\n/**\n * This object will be used as the prototype for Nodes when creating a\n * DOM-Level-1-compliant structure.\n */\nexport var Node = /*#__PURE__*/function () {\n  function Node() {\n    _classCallCheck(this, Node);\n    /** Parent of the node */\n    this.parent = null;\n    /** Previous sibling */\n    this.prev = null;\n    /** Next sibling */\n    this.next = null;\n    /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */\n    this.startIndex = null;\n    /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */\n    this.endIndex = null;\n  }\n  // Read-write aliases for properties\n  /**\n   * Same as {@link parent}.\n   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n   */\n  _createClass(Node, [{\n    key: \"cloneNode\",\n    /**\n     * Clone this node, and optionally its children.\n     *\n     * @param recursive Clone child nodes as well.\n     * @returns A clone of the node.\n     */\n    value: function cloneNode() {\n      var recursive = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      return _cloneNode(this, recursive);\n    }\n  }, {\n    key: \"parentNode\",\n    get: function get() {\n      return this.parent;\n    },\n    set: function set(parent) {\n      this.parent = parent;\n    }\n    /**\n     * Same as {@link prev}.\n     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n     */\n  }, {\n    key: \"previousSibling\",\n    get: function get() {\n      return this.prev;\n    },\n    set: function set(prev) {\n      this.prev = prev;\n    }\n    /**\n     * Same as {@link next}.\n     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n     */\n  }, {\n    key: \"nextSibling\",\n    get: function get() {\n      return this.next;\n    },\n    set: function set(next) {\n      this.next = next;\n    }\n  }]);\n  return Node;\n}();\n/**\n * A node that contains some data.\n */\nexport var DataNode = /*#__PURE__*/function (_Node) {\n  _inherits(DataNode, _Node);\n  /**\n   * @param data The content of the data node\n   */\n  function DataNode(data) {\n    var _this;\n    _classCallCheck(this, DataNode);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(DataNode).call(this));\n    _this.data = data;\n    return _this;\n  }\n  /**\n   * Same as {@link data}.\n   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n   */\n  _createClass(DataNode, [{\n    key: \"nodeValue\",\n    get: function get() {\n      return this.data;\n    },\n    set: function set(data) {\n      this.data = data;\n    }\n  }]);\n  return DataNode;\n}(Node);\n/**\n * Text within the document.\n */\nexport var Text = /*#__PURE__*/function (_DataNode) {\n  _inherits(Text, _DataNode);\n  function Text() {\n    var _this2;\n    _classCallCheck(this, Text);\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Text).apply(this, arguments));\n    _this2.type = ElementType.Text;\n    return _this2;\n  }\n  _createClass(Text, [{\n    key: \"nodeType\",\n    get: function get() {\n      return 3;\n    }\n  }]);\n  return Text;\n}(DataNode);\n/**\n * Comments within the document.\n */\nexport var Comment = /*#__PURE__*/function (_DataNode2) {\n  _inherits(Comment, _DataNode2);\n  function Comment() {\n    var _this3;\n    _classCallCheck(this, Comment);\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(Comment).apply(this, arguments));\n    _this3.type = ElementType.Comment;\n    return _this3;\n  }\n  _createClass(Comment, [{\n    key: \"nodeType\",\n    get: function get() {\n      return 8;\n    }\n  }]);\n  return Comment;\n}(DataNode);\n/**\n * Processing instructions, including doc types.\n */\nexport var ProcessingInstruction = /*#__PURE__*/function (_DataNode3) {\n  _inherits(ProcessingInstruction, _DataNode3);\n  function ProcessingInstruction(name, data) {\n    var _this4;\n    _classCallCheck(this, ProcessingInstruction);\n    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(ProcessingInstruction).call(this, data));\n    _this4.name = name;\n    _this4.type = ElementType.Directive;\n    return _this4;\n  }\n  _createClass(ProcessingInstruction, [{\n    key: \"nodeType\",\n    get: function get() {\n      return 1;\n    }\n  }]);\n  return ProcessingInstruction;\n}(DataNode);\n/**\n * A `Node` that can have children.\n */\nexport var NodeWithChildren = /*#__PURE__*/function (_Node2) {\n  _inherits(NodeWithChildren, _Node2);\n  /**\n   * @param children Children of the node. Only certain node types can have children.\n   */\n  function NodeWithChildren(children) {\n    var _this5;\n    _classCallCheck(this, NodeWithChildren);\n    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(NodeWithChildren).call(this));\n    _this5.children = children;\n    return _this5;\n  }\n  // Aliases\n  /** First child of the node. */\n  _createClass(NodeWithChildren, [{\n    key: \"firstChild\",\n    get: function get() {\n      var _a;\n      return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;\n    } /** Last child of the node. */\n  }, {\n    key: \"lastChild\",\n    get: function get() {\n      return this.children.length > 0 ? this.children[this.children.length - 1] : null;\n    }\n    /**\n     * Same as {@link children}.\n     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n     */\n  }, {\n    key: \"childNodes\",\n    get: function get() {\n      return this.children;\n    },\n    set: function set(children) {\n      this.children = children;\n    }\n  }]);\n  return NodeWithChildren;\n}(Node);\nexport var CDATA = /*#__PURE__*/function (_NodeWithChildren) {\n  _inherits(CDATA, _NodeWithChildren);\n  function CDATA() {\n    var _this6;\n    _classCallCheck(this, CDATA);\n    _this6 = _possibleConstructorReturn(this, _getPrototypeOf(CDATA).apply(this, arguments));\n    _this6.type = ElementType.CDATA;\n    return _this6;\n  }\n  _createClass(CDATA, [{\n    key: \"nodeType\",\n    get: function get() {\n      return 4;\n    }\n  }]);\n  return CDATA;\n}(NodeWithChildren);\n/**\n * The root node of the document.\n */\nexport var Document = /*#__PURE__*/function (_NodeWithChildren2) {\n  _inherits(Document, _NodeWithChildren2);\n  function Document() {\n    var _this7;\n    _classCallCheck(this, Document);\n    _this7 = _possibleConstructorReturn(this, _getPrototypeOf(Document).apply(this, arguments));\n    _this7.type = ElementType.Root;\n    return _this7;\n  }\n  _createClass(Document, [{\n    key: \"nodeType\",\n    get: function get() {\n      return 9;\n    }\n  }]);\n  return Document;\n}(NodeWithChildren);\n/**\n * An element within the DOM.\n */\nexport var Element = /*#__PURE__*/function (_NodeWithChildren3) {\n  _inherits(Element, _NodeWithChildren3);\n  /**\n   * @param name Name of the tag, eg. `div`, `span`.\n   * @param attribs Object mapping attribute names to attribute values.\n   * @param children Children of the node.\n   */\n  function Element(name, attribs) {\n    var _this8;\n    var children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    var type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : name === \"script\" ? ElementType.Script : name === \"style\" ? ElementType.Style : ElementType.Tag;\n    _classCallCheck(this, Element);\n    _this8 = _possibleConstructorReturn(this, _getPrototypeOf(Element).call(this, children));\n    _this8.name = name;\n    _this8.attribs = attribs;\n    _this8.type = type;\n    return _this8;\n  }\n  _createClass(Element, [{\n    key: \"nodeType\",\n    get: function get() {\n      return 1;\n    } // DOM Level 1 aliases\n    /**\n     * Same as {@link name}.\n     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n     */\n  }, {\n    key: \"tagName\",\n    get: function get() {\n      return this.name;\n    },\n    set: function set(name) {\n      this.name = name;\n    }\n  }, {\n    key: \"attributes\",\n    get: function get() {\n      var _this9 = this;\n      return Object.keys(this.attribs).map(function (name) {\n        var _a, _b;\n        return {\n          name: name,\n          value: _this9.attribs[name],\n          namespace: (_a = _this9[\"x-attribsNamespace\"]) === null || _a === void 0 ? void 0 : _a[name],\n          prefix: (_b = _this9[\"x-attribsPrefix\"]) === null || _b === void 0 ? void 0 : _b[name]\n        };\n      });\n    }\n  }]);\n  return Element;\n}(NodeWithChildren);\n/**\n * @param node Node to check.\n * @returns `true` if the node is a `Element`, `false` otherwise.\n */\nexport function isTag(node) {\n  return isTagRaw(node);\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `CDATA`, `false` otherwise.\n */\nexport function isCDATA(node) {\n  return node.type === ElementType.CDATA;\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `Text`, `false` otherwise.\n */\nexport function isText(node) {\n  return node.type === ElementType.Text;\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `Comment`, `false` otherwise.\n */\nexport function isComment(node) {\n  return node.type === ElementType.Comment;\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.\n */\nexport function isDirective(node) {\n  return node.type === ElementType.Directive;\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.\n */\nexport function isDocument(node) {\n  return node.type === ElementType.Root;\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has children, `false` otherwise.\n */\nexport function hasChildren(node) {\n  return Object.prototype.hasOwnProperty.call(node, \"children\");\n}\n/**\n * Clone a node, and optionally its children.\n *\n * @param recursive Clone child nodes as well.\n * @returns A clone of the node.\n */\nfunction _cloneNode(node) {\n  var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var result;\n  if (isText(node)) {\n    result = new Text(node.data);\n  } else if (isComment(node)) {\n    result = new Comment(node.data);\n  } else if (isTag(node)) {\n    var children = recursive ? cloneChildren(node.children) : [];\n    var clone = new Element(node.name, _objectSpread({}, node.attribs), children);\n    children.forEach(function (child) {\n      return child.parent = clone;\n    });\n    if (node.namespace != null) {\n      clone.namespace = node.namespace;\n    }\n    if (node[\"x-attribsNamespace\"]) {\n      clone[\"x-attribsNamespace\"] = _objectSpread({}, node[\"x-attribsNamespace\"]);\n    }\n    if (node[\"x-attribsPrefix\"]) {\n      clone[\"x-attribsPrefix\"] = _objectSpread({}, node[\"x-attribsPrefix\"]);\n    }\n    result = clone;\n  } else if (isCDATA(node)) {\n    var _children = recursive ? cloneChildren(node.children) : [];\n    var _clone = new CDATA(_children);\n    _children.forEach(function (child) {\n      return child.parent = _clone;\n    });\n    result = _clone;\n  } else if (isDocument(node)) {\n    var _children2 = recursive ? cloneChildren(node.children) : [];\n    var _clone2 = new Document(_children2);\n    _children2.forEach(function (child) {\n      return child.parent = _clone2;\n    });\n    if (node[\"x-mode\"]) {\n      _clone2[\"x-mode\"] = node[\"x-mode\"];\n    }\n    result = _clone2;\n  } else if (isDirective(node)) {\n    var instruction = new ProcessingInstruction(node.name, node.data);\n    if (node[\"x-name\"] != null) {\n      instruction[\"x-name\"] = node[\"x-name\"];\n      instruction[\"x-publicId\"] = node[\"x-publicId\"];\n      instruction[\"x-systemId\"] = node[\"x-systemId\"];\n    }\n    result = instruction;\n  } else {\n    throw new Error(\"Not implemented yet: \".concat(node.type));\n  }\n  result.startIndex = node.startIndex;\n  result.endIndex = node.endIndex;\n  if (node.sourceCodeLocation != null) {\n    result.sourceCodeLocation = node.sourceCodeLocation;\n  }\n  return result;\n}\nexport { _cloneNode as cloneNode };\nfunction cloneChildren(childs) {\n  var children = childs.map(function (child) {\n    return _cloneNode(child, true);\n  });\n  for (var i = 1; i < children.length; i++) {\n    children[i].prev = children[i - 1];\n    children[i - 1].next = children[i];\n  }\n  return children;\n}","map":null,"metadata":{},"sourceType":"module"}